<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>showSelected</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="Ch03-showSelected_files/libs/clipboard/clipboard.min.js"></script>
<script src="Ch03-showSelected_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="Ch03-showSelected_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="Ch03-showSelected_files/libs/quarto-html/popper.min.js"></script>
<script src="Ch03-showSelected_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Ch03-showSelected_files/libs/quarto-html/anchor.min.js"></script>
<link href="Ch03-showSelected_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Ch03-showSelected_files/libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Ch03-showSelected_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Ch03-showSelected_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Ch03-showSelected_files/libs/bootstrap/bootstrap-b246a02ba367c9dcfbf2776f6d050791.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">showSelected</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="chapter-3-the-showselected-keyword" class="level1">
<h1>Chapter 3, the showSelected keyword</h1>
<p>Ce chapitre explique <code>showSelected</code>, l’un des deux principaux mots-clés introduits par <code>animint2</code> pour la visualisation interactive de données. Après avoir lu ce chapitre, vous serez en mesure de</p>
<ul>
<li>Utiliser le mot-clé <code>showSelected</code> dans vos esquisses pour spécifier des geoms pour lesquels seul un sous-ensemble de données doit être tracé à la fois.</li>
<li>Utiliser les menus de sélection pour modifier le sous-ensemble de données tracées.</li>
<li>Spécifier des transitions fluides entre les sous-ensembles de données à l’aide de l’option <code>duration</code> et <code>aes(key)</code>.</li>
<li>Créer des visualisations de données animées à l’aide de l’option <code>time</code>.</li>
</ul>
<section id="esquisses" class="level2">
<h2 class="anchored" data-anchor-id="esquisses">Esquisses avec <code>showSelected</code></h2>
<p>Dans le chapitre 2, nous avons expliqué comment vous pouvez plannifier les codes nécessaires pour créer une visualisation, à l’aide d’une esquisse qui comprend les éléments principaux (geoms, axes, légendes, données). Dans cette section, nous allons expliquer comment le mot-clé <code>showSelected</code> peut être utilisé dans les esquisses. Le mot-clé <code>showSelected</code> spécifie une variable à utiliser pour sélectionner un sous-ensemble de données. Chaque geom d’une visualisation de données possède son propre ensemble de données, et sa propre définition des variables <code>showSelected</code>. Cela signifie que des geoms différents peuvent spécifier des ensembles de données et des mots-clés <code>showSelected</code> différents pour afficher des sous-ensembles de données différents.</p>
<p>En fait, nous avons déjà utilisé le mot-clé <code>showSelected</code>, qui a été automatiquement créé par les légendes interactives que nous avons créées dans les deux chapitres précédents. Par exemple, considérons l’esquisse ci-dessous, de <a href="Ch01-motivation.html#large-data">la courbe de Keeling du chapitre 1</a>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Ch03-viz-co2.png" class="img-fluid figure-img"></p>
<figcaption>Esquisse de la courbe de Keeling</figcaption>
</figure>
</div>
<p>L’esquisse ci-dessus comprend <code>showSelected=mois</code> pour le <code>geom_point</code> ce qui signifie qu’il doit afficher le sous-ensemble de données pour les mois sélectionnés. En revanche, étant donné que <code>geom_line</code> n’inclut pas <code>showSelected</code>, il affiche toujours l’ensemble complet des données (quels que soient les mois sélectionnés).</p>
<p>Prenons un autre exemple : le dessin ci-dessous de la première visualisation de données de la banque mondiale, du chapitre 2.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Ch03-viz-showSelectedColor.png" class="img-fluid figure-img"></p>
<figcaption>Esquisse banque mondiale avec showSelected région</figcaption>
</figure>
</div>
<p>L’esquisse ci-dessus spécifie <code>showSelected=région</code> pour le <code>geom_point</code>, ce qui signifie qu’il doit afficher le sous-ensemble de données pour les régions sélectionnées.</p>
<p>Notez que le code que nous avons utilisé dans chapitre 2 ne spécifiait pas explicitement <code>showSelected=région</code>. Au lieu de cela, nous avons spécifié <code>aes(color=région)</code> et <code>animint2</code> a automatiquement rajouté un mot-clé <code>showSelected</code>. En général, <code>animint2</code> rajoute un mot-clé <code>showSelected</code> pour chaque variable utilisée dans une légende qualitative.</p>
<p>Cependant, le mot-clé <code>showSelected</code> n’est pas limité aux légendes qualitatives. Vous pouvez utiliser les mots-clés <code>showSelected</code> pour toutes les variables que vous souhaitez, en spécifiant explicitement les noms des variables dans l’argument <code>showSelected</code> du geom.</p>
<p>Chaque variable utilisée avec <code>showSelected</code> est traitée par <code>animint2</code> comme une variable de sélection. Par exemple, la visualisation de la courbe de Keeling a une variable de sélection (<code>mois</code>), tout comme la visualisation de la Banque Mondiale (<code>région</code>). Pour chaque variable de sélection, <code>animint2</code> stocke les valeurs actuellement sélectionnées. Lorsque la sélection change, <code>animint2</code> met à jour le sous-ensemble de données affiché.</p>
<p>Chacune des visualisations esquissées ci-dessus ne comporte qu’une seule variable de sélection. Cependant, une visualisation de données peut comporter un nombre quelconque de variables de sélection. Dans la section suivante, nous allons étudier une visualisation des données de la Banque Mondiale, qui comporte des variables de sélection pour <code>région</code> et <code>année</code>.</p>
</section>
<section id="selection-avec-menus" class="level2">
<h2 class="anchored" data-anchor-id="selection-avec-menus">Sélection de sous-ensembles avec menus</h2>
<p>Considérons l’esquisse suivant, avec une variable <code>showSelected</code> de plus, et avec un différent ensemble de données.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Ch03-viz-scatter.png" class="img-fluid figure-img"></p>
<figcaption>Esquisse banque mondiale avec showSelected région et année</figcaption>
</figure>
</div>
<p>Notez qu’il y a deux variables <code>showSelected</code> : <code>région</code> et <code>année</code>. Notez également que les données sont spécifiées pour toutes les années (mais une seule année sera affichée à la fois, grâce au <code>showSelected=année</code>). Ci-dessous, nous traduisons l’esquisse en code R.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(animint2)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(BanqueMondiale, <span class="at">package=</span><span class="st">"animint2fr"</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>nuage <span class="ot">&lt;-</span> <span class="fu">ggplot</span>()<span class="sc">+</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="fu">aes</span>(</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">x=</span>espérance.de.vie, <span class="at">y=</span>taux.de.fertilité, <span class="at">color=</span>région),</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">showSelected=</span><span class="st">"année"</span>,</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">data=</span>BanqueMondiale)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>nuage</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Warning: Removed 1490 rows containing missing values (geom_point).</code></pre>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Ch03-figures/unnamed-chunk-1-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Notez que le code ci-dessus contient le mot-clé <code>showSelected</code>, ce qui est nouveau dans <code>animint2</code>, par rapport à <code>ggplot2</code>. Le mot-clé <code>showSelected</code> est ignoré lorsque le graphe est affiché comme ci-dessus, avec les fonctions d’affichage habituelles dans R, qui dessinent un nuage de points qui comprend toutes les années.</p>
<p>En revanche, donner le code ci-dessus comme argument pour <code>animint()</code> donne la visualisation interactive ci-dessous, qui dessine une année à la fois.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">animint</span>(nuage)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<script type="text/javascript" src="Ch03vizscatter/vendor/d3.v3.js"></script>
<script type="text/javascript" src="Ch03vizscatter/animint.js"></script>
<script type="text/javascript" src="Ch03vizscatter/vendor/jquery-1.11.3.min.js"></script>
<script type="text/javascript" src="Ch03vizscatter/vendor/selectize.min.js"></script>
<link rel="stylesheet" type="text/css" href="Ch03vizscatter/vendor/selectize.css">
<script type="text/javascript" src="Ch03vizscatter/vendor/driver.js.iife.js"></script>
<link rel="stylesheet" href="Ch03vizscatter/vendor/driver.css">
<p>
</p>
<div id="Ch03vizscatter">

</div>
<script>var Ch03vizscatter = new animint("#Ch03vizscatter", "Ch03vizscatter/plot.json");</script>
</div>
</div>
<p>Notez que la visualisation ci-dessus comporte deux variables de sélection : <code>région</code> et <code>année</code> (<code>color=région</code> fait que <code>région</code> est automatiquement une variable <code>showSelected</code>). Chaque variable dispose d’un menu en bas qui peut être utilisé pour modifier la sélection en cours. Dans cette visualisation, ces menus sont affichés par défaut. Ils peuvent être masqués en cliquant sur le bouton “Hide selection menus”, et réaffichés en cliquant sur le bouton “Show selection menus”.</p>
<p>Les variables discrètes, telles que <code>région</code>, ont la sélection multiple par défaut, de sorte que plusieurs valeurs sont sélectionnées et affichées à la fois. Essayez de modifier la région sélectionnée dans la légende interactive et dans le menu de sélection. Lorsque vous modifiez la sélection à l’aide d’une des méthodes, la légende interactive et le menu de sélection sont tous les deux mis à jour, pour refléter la sélection actuelle.</p>
<p>Nous utilisons les termes “manipulation directe” et “manipulation indirecte” pour décrire ces différentes façons de modifier la sélection. La manipulation directe est généralement plus facile à comprendre, parce qu’il s’agit de cliquer sur les objets que l’on souhaite modifier dans le graphique. En revanche, les techniques de manipulation indirecte, telles que les menus, sont utiles dans d’autres cas (par exemple, sélection d’un pays par nom). Dans la visualisation ci-dessus, vous pouvez modifier la valeur de <code>région</code> en utilisant soit la légende, soit le menu. L’utilisation de la légende est une technique de manipulation plus directe, puisque la légende est dessinée plus près du nuage de points qui sera mis à jour.</p>
<p>D’autres variables de sélection, comme <code>année</code>, ont la sélection simple par défaut, de sorte qu’une seule valeur est sélectionnée et affichée à la fois. Essayez de modifier la valeur sélectionnée de la variable <code>année</code>, à l’aide du menu de sélection. Vous devriez voir le nuage de points se mettre à jour immédiatement pour afficher le taux de fertilité et l’espérance de vie de tous les pays au cours de l’année que vous avez sélectionnée.</p>
<p>Exercice multi-couche : ajoutez un autre geom à ce nuage de points interactif. Comme dans le <a href="Ch02-ggplot2.html#multi-layer">Chapitre 2</a> vous pouvez utiliser un <code>geom_text</code> pour afficher le nom de chaque pays (facile), ou un <code>geom_text</code> pour afficher l’année sélectionnée (moyen), ou un <code>geom_path</code> pour afficher les données des 5 années précédentes (difficile). Astuce : utilisez <code>showSelected=année</code> dans tous les geoms.</p>
<p>Exercice multi-geom : ajoutez une série temporelle à la visualisation de données ci-dessus. Comme dans le <a href="Ch02-ggplot2.html#multi-plot">Chapitre 2</a> vous pouvez utiliser un <code>geom_line</code> pour afficher le taux de fertilité de chaque pays, pour toutes les années. Ajoutez un <code>geom_vline</code> avec <code>showSelected=année</code> pour mettre en évidence l’année sélectionnée.</p>
</section>
<section id="duration-key" class="level2">
<h2 class="anchored" data-anchor-id="duration-key">Transitions : l’option <code>duration</code> et <code>aes(key)</code></h2>
<p>Vous avez peut-être remarqué qu’il y a des boutons en bas de chaque visualisation de données créée par animint2. Essayez de cliquer sur le bouton “Show animation controls” ci-dessus. Ce tableau contient une ligne pour chaque variable de sélection. Les zones de texte indiquent le nombre de millisecondes utilisées pour les durées de transition après la mise à jour de chaque variable de sélection. Pour chaque variable de sélection, la durée de transition par défaut est 0, ce qui signifie que les données seront immédiatement placées à leur nouvelle position après la mise à jour de chaque variable.</p>
<p>Pour illustrer l’importance des durées de transition, essayez de changer la valeur de la durée de transition de la variable <code>année</code> à 2000. Ensuite, utilisez le menu pour modifier la valeur sélectionnée de la variable <code>année</code>. Vous devriez voir les points de données se déplacer lentement vers leurs nouvelles positions, sur une durée de 2 secondes.</p>
<p>Certaines transitions n’entraînent qu’un léger déplacement des points vers des positions proches (par exemple, 1979-1980). D’autres transitions entraînent un déplacement beaucoup plus important des points, vers des localisations plus éloignées (par exemple 1980-1981). Comment cela se fait-il ?</p>
<p>Les transitions fluides n’ont de sens que pour les points de données qui existent à la fois avant et après la modification de la sélection. Dans le code R ci-dessous, nous calculons un tableau de contingences des points de données qui peuvent être tracés dans chacune de ces trois années.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>trois.ans <span class="ot">&lt;-</span> <span class="fu">subset</span>(BanqueMondiale, <span class="dv">1979</span> <span class="sc">&lt;=</span> année <span class="sc">&amp;</span> année <span class="sc">&lt;=</span> <span class="dv">1981</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>can.plot <span class="ot">&lt;-</span> <span class="fu">with</span>(trois.ans, {</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  (<span class="sc">!</span><span class="fu">is.na</span>(espérance.de.vie)) <span class="sc">&amp;</span> (<span class="sc">!</span><span class="fu">is.na</span>(taux.de.fertilité))</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="fu">table</span>(trois.ans<span class="sc">$</span>année, can.plot)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>      can.plot
       FALSE TRUE
  1979    27  187
  1980    27  187
  1981    26  188</code></pre>
</div>
</div>
<p>Le tableau de contingence ci-dessus montre clairement que 187 points peuvent être tracés en 1979 et 1980. Cependant, en 1981, il y a un point de données supplémentaire, correspondant à un pays pour lequel nous n’avions pas de données en 1980. Nous présentons ci-dessous les données de ce pays, le Kosovo.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">subset</span>(trois.ans, pays<span class="sc">==</span><span class="st">"Kosovo"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     iso2c country year fertility.rate life.expectancy population
5850    KV  Kosovo 1979             NA              NA    1491000
5851    KV  Kosovo 1980             NA              NA    1521000
5852    KV  Kosovo 1981         4.5758        65.93268    1552000
     GDP.per.capita.Current.USD 15.to.25.yr.female.literacy iso3c
5850                         NA                          NA   KSV
5851                         NA                          NA   KSV
5852                         NA                          NA   KSV
                                        region  capital longitude latitude
5850 Europe &amp; Central Asia (all income levels) Pristina    20.926   42.565
5851 Europe &amp; Central Asia (all income levels) Pristina    20.926   42.565
5852 Europe &amp; Central Asia (all income levels) Pristina    20.926   42.565
                  income lending                Region                  région
5850 Lower middle income     IDA Europe &amp; Central Asia Europe et Asie centrale
5851 Lower middle income     IDA Europe &amp; Central Asia Europe et Asie centrale
5852 Lower middle income     IDA Europe &amp; Central Asia Europe et Asie centrale
     espérance.de.vie taux.de.fertilité année   pays PIB.par.habitant.USD
5850               NA                NA  1979 Kosovo                   NA
5851               NA                NA  1980 Kosovo                   NA
5852         65.93268            4.5758  1981 Kosovo                   NA
     alphabétisation           revenu
5850              NA Revenu moyen bas
5851              NA Revenu moyen bas
5852              NA Revenu moyen bas</code></pre>
</div>
</div>
<p>En effet, le tableau de contingence ci-dessus montre que le taux de fertilité et l’espérance de vie sont manquants pour le Kosovo en 1979-1980. Il n’est donc pas logique d’effectuer une transition en douceur pour des pays tels que le Kosovo, qui ne seraient pas tracés ni avant ni après la transition. Comment spécifier cela dans la visualisation de données ? Dans le code ci-dessous, nous utilisons <code>aes(key=pays)</code> pour spécifier que les <code>pays</code> doit être utilisée pour faire correspondre les points de données avant et après la modification de la sélection.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>nuage.key <span class="ot">&lt;-</span> <span class="fu">ggplot</span>()<span class="sc">+</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="fu">aes</span>(</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">x=</span>espérance.de.vie, <span class="at">y=</span>taux.de.fertilité, <span class="at">color=</span>région,</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">key=</span>pays),</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">showSelected=</span><span class="st">"année"</span>,</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">data=</span>BanqueMondiale)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Le <code>key</code> dans le ggplot ci-dessus n’a de sens que pour la visualisation interactive des données, il est donc ignoré lorsqu’il est affiché avec les périphériques graphiques R habituels. Cependant, si nous affichons ce ggplot en utilisant animint2, la variable <code>pays</code> sera utilisée pour s’assurer que les durées de transition sont significatives. Pour spécifier une durée de transition par défaut pour la variable <code>année</code> nous utilisons l’option <code>duration</code> dans l’image de données ci-dessous.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>(viz.duration <span class="ot">&lt;-</span> <span class="fu">animint</span>(nuage.key, <span class="at">duration=</span><span class="fu">list</span>(année<span class="ot">=</span><span class="dv">2000</span>)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p></p>
<div id="Ch03vizduration"></div>
<script>var Ch03vizduration = new animint("#Ch03vizduration", "Ch03vizduration/plot.json");</script>
</div>
</div>
<p>L’option <code>duration</code> doit être une liste nommée. Chaque nom doit être une variable de sélection et chaque valeur doit spécifier le nombre de millisecondes à utiliser pour la durée de la transition lorsque la valeur sélectionnée de cette variable est modifiée.</p>
<p>Si vous cliquez sur “Show animation controls” (Afficher les contrôles d’animation) dans le graphique ci-dessus, vous verrez que la zone de texte pour la variable année est 2000, comme spécifié dans le code R. Si vous changez la sélection de 1980 à 1981, vous devriez voir une transition correcte.</p>
<p>De façon générale, <code>aes(key)</code> doit être spécifiée pour tous les geoms qui utilisent le mot-clé <code>showSelected</code> avec une variable qui apparaît dans l’option <code>duration</code>. Dans cet exemple, nous avons utilisé l’option <code>duration</code> pour spécifier une transition en douceur pour la variable <code>année</code>. Puisque nous utilisons <code>showSelected=année</code> dans <code>geom_point</code> nous avons également spécifié <code>aes(key)</code> pour ce geom.</p>
</section>
<section id="animation-time" class="level2">
<h2 class="anchored" data-anchor-id="animation-time">Animation : l’option <code>time</code></h2>
<p>L’option <code>time</code> permet de spécifier une variable à utiliser pour l’animation. Dans le code en-dessous, on utilise l’option <code>time</code> pour préciser <code>année</code> comme variable d’animation, avec mises à jour tous les 2000 millisecondes.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>viz.duration.time <span class="ot">&lt;-</span> viz.duration</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>viz.duration.time<span class="sc">$</span>time <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">variable=</span><span class="st">"année"</span>, <span class="at">ms=</span><span class="dv">2000</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>viz.duration.time</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p></p>
<div id="Ch03vizdurationtime"></div>
<script>var Ch03vizdurationtime = new animint("#Ch03vizdurationtime", "Ch03vizdurationtime/plot.json");</script>
</div>
</div>
<p>On dit que la visualisation en-dessus est animée, parce que la sélection pour <code>année</code> va changer tous les deux secondes.</p>
<p>Exercice : réalisez une visualisation de données animée qui n’utilise PAS de transitions fluides. Indice : créez une liste de ggplots qui possède l’option <code>time</code> mais pas l’option <code>duration</code>.</p>
</section>
<section id="exercises" class="level2">
<h2 class="anchored" data-anchor-id="exercises">Résumé du chapitre et exercices</h2>
<p>Ce chapitre a expliqué le mot-clé <code>showSelected</code>, les menus de sélection, les transitions et l’animation.</p>
<p>Exercices :</p>
<ul>
<li>Réaliser une version améliorée de <code>vis.alignée</code> du chapitre précédent. Au lieu de fixer l’année à 1975, utilisez <code>showSelected=année</code> pour que l’utilisateur puisse sélectionner une année. Ajoutez des geoms qui affichent l’année sélectionnée : a <code>geom_text</code> sur le nuage de points, et un <code>geom_vline</code> sur la série chronologique.</li>
<li>Traduisez l’un des <a href="https://yihui.name/animation/examples/">exemples de library(animation)</a> en animint2. Indice : dans le code de library(animation), il y a toujours une boucle <code>for</code> sur l’option <code>time</code>. Au lieu d’appeler une fonction d’affichage à l’intérieur de la boucle <code>for</code>, utilisez <a href="Ch99-appendix.html#list-of-data-tables">l’idiome liste de tableaux de données</a> pour stocker les données qui doivent être tracées. Utilisez ensuite ces données avec <code>showSelected</code> pour créer des ggplots, et les afficher avec <code>animint2</code>.</li>
</ul>
<p>Ensuite, <a href="Ch04-clickSelects.html">Chapitre 4</a> explique les <code>clickSelects</code> qui indique un geom sur lequel on peut cliquer pour mettre à jour une variable de sélection.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>